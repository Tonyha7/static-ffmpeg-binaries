name: GitHub Repo API Action

description: |
  A reusable action to talk to the GitHub API, wihtout relying on external
  actions that could be affected by a supply-chain attack.

inputs:
  username:
    description: A username for authentication to the GitHub API.
    required: true
  token:
    description: A token for authentication to the GitHub API.
    required: true
  method:
    description: A high-level method to invoke.  See action source for details.
    required: true

outputs:
  release_id:
    description: The ID of a newly-created release from the draft_release method
    value: ${{ steps.call-repo-api.outputs.release_id }}

runs:
  using: composite
  steps:
    - name: Call Repo API
      id: call-repo-api
      shell: python3 {0}
      run: |
        import base64
        import json
        import mimetypes
        import os
        import urllib.request

        def call_api(path, data=None, headers=None, method=None, get_json=True,
                     upload=False):
          repo = os.environ["GITHUB_REPOSITORY"]
          if upload:
            url = "https://uploads.github.com/repos/{}{}".format(repo, path)
          else:
            url = "https://api.github.com/repos/{}{}".format(repo, path)
          login = "${{ inputs.username }}:${{ inputs.token }}"

          if not headers:
            headers = {}
          if not method:
            method = "POST" if data else "GET"

          # For debugging:
          #print({
          #  "method": method,
          #  "path": path,
          #  "url": url,
          #  "headers": headers,
          #  "data": data,
          #})

          auth_token = base64.b64encode(login.encode("utf-8")).decode("utf-8")
          headers["Authorization"] = "Basic {}".format(auth_token)

          if type(data) is dict:
            data_bytes = json.dumps(data).encode("utf-8")
            headers["Content-Type"] = "application/json"
          elif type(data) is str:
            data_bytes = data.encode("utf-8")
          elif not data:
            data_bytes = None
          else:
            assert(type(data) is bytes)
            data_bytes = data

          req = urllib.request.Request(url, data_bytes, headers)
          with urllib.request.urlopen(req) as resp:
            if get_json:
              body = json.load(resp)
              return body
            else:
              return resp.read()

        def draft_release(tag_name):
          # Turns "refs/tags/foo" into "foo"
          tag_name = tag_name.split("/").pop()

          data = {
            "tag_name": tag_name,
            "name": tag_name,
            "draft": True,
          }
          body = call_api("/releases", data)
          #print("Draft release body:", body)
          release_id = str(body["id"])
          print("::set-output name=release_id::{}".format(release_id))

        def upload_asset(release_id, asset_path, mime_type):
          base_name = os.path.basename(asset_path)
          path = "/releases/{}/assets?name={}".format(release_id, base_name)
          with open(asset_path, "rb") as f:
            data = f.read()
          headers = {"Content-Type": mime_type}
          call_api(path, data, headers, upload=True)

        def upload_all_assets(release_id, folder):
          for asset in os.listdir(folder):
            asset_path = os.path.join(folder, asset)
            # This returns a tuple of (type, encoding), where type can be None
            mime_type = mimetypes.guess_type(asset_path)[0]
            if not mime_type:
              mime_type = "application/octet-stream"
            upload_asset(release_id, asset_path, mime_type)

        def download_all_assets(release_id, output_path):
          if not os.path.exists(output_path):
            os.mkdir(output_path)

          path = "/releases/{}/assets".format(release_id)
          asset_list = call_api(path)
          for asset in asset_list:
            name = asset["name"]
            url = asset["browser_download_url"]
            #print("Downloading: ", url)
            with urllib.request.urlopen(url) as download:
              with open(os.path.join(output_path, name), "wb") as local_file:
                local_file.write(download.read())

        def update_release(release_id, **data):
          path = "/releases/{}".format(release_id)
          call_api(path, data, method="PATCH")

        ${{ inputs.method }}
